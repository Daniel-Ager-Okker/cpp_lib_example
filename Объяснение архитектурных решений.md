# Объяснение архитектурных решений

## API библиотеки

Набор публичных методов класса `EmployeeManager`:

`calculate_total_salary`: решение принципиальной задачи библиотеки по расчету суммарной зп по заводу за месяц; **важный аспект**: возврат double; так как зп может содержать дробную часть (копейки)

`calculate_typed_salary`: функция для возможного ведения статистики зп по должностям со стороны гипотетического ПО

`calculate_employee_salary`: расчет заработной платы одного сотрудника (опять-таки, гипотетическая необходимость для расчета статистики)

`add_employee`: регистрация сотрудника (например, трудоустройство нового человека)

`remove_employee`: удаление сотрудника (например, увольнение)

`find_employee`: поиск сотрудника в справочнике (например, для изменения его свойств; переназначение начальника/подчиненных);

`add_subordination`: задача связи начальника с подчиненным

`remove_subordination`: удаление связи начальник-подчиненный

`get_subordinates`: поиск всех подчиненных сотрудника

`get_chief`: поиск начальница сотрудника; примечание: возврат std::optional, так как начальника может и не быть

Также публичная структура `EmployeeDescr` вкупе с перечислением `EmployeeType`, оба  служат цели описать сотрудника на уровне использующего библиотеку приложения.

Класс `EmployeeManager` ответственнен за хранение объектов, за их создание и удаление. Он определяет время жизни, поэтому логично ему в приватные поля подсунуть контейнер с объектами. Но объект описывается асбтрактным классом `Employee` (о нем ниже), выводить наружу который не хотелось бы. Так, для решения этой задачи используется паттерн PIMPL, когда в качестве поля используется приватный класс `PrivateData`, содержащий контейнер с экземплярами `Employee`.

На этом заканчивается публичная часть библиотеки. Описанные ниже классы - это детали реализации, которые скрыты от стороны, использующей библиотеку.

## Детали реализации

Абстрактный класс `Employee` служит единым описанием того, какие действия можно сделать с сущностью "сотрудник"" на уровне бизнес-логики.

Ключевые аспекты:

- сделать конструктор класса `Employee` доступным только наследникам, а конструкторы наследников - полностью закрыть, для создания объектов используя паттерн *фабричный метод*; класс `Employee` при этом сделать friend-ом; обоснование: инкапсуляция создания ровно в одном месте, а также делегирование логики создания объектов конкретных категорий самим категориям 

###### Рабочая иерархия "власти"

Задача хранения связей "начальник-подчиненный" может быть архитектурно реализована двумя путями:

1. хранить указатель на начальника и иметь коллекцию указателей на подчиненных в классе непосредственно

2. выделить отдельный класс, отвечающий за логику обработки/хранения

Первый способ мне нравится меньше, так как:

- он сразу заставляет задуматься над вопросами создания объектов на куче, чтобы грамотно описывать логику указателей на начальника/подчиненного в самом классе-реализации

- как следствие: если создавать объекты на куче, то сразу ряд проблем по тому, в какой момент времени их создавать, когда чистить память и т.д.

- способ накладывает требование на написание более хитрого деструктора (уволили сотрудника, объект уничтожается, при этом из коллекции начальника необходимо тоже его удалить) и методов по удалению/добавлению подчиненных (как будто чуть больше логики на себя берет класс `Employee`, чем хотелось бы)

Второй способ импонирует больше:

- выносим логику обработки ассоциаций в отдельную сущность, соблюдая принцип single responsibility, не нагружая класс `Employee`, делая его ответственным за логику иерархии

- в будущем логика работы с отношениями может усложняться (сериализация в БД/файл), сразу закладываемся на масштабируемость

- не храним сами объекты как указатели, а осуществляем связь по id-шникам, не вводя в архитектуру проблемы владения

- имеем возможность валидировать отношения в одном месте (может в будущем потребоваться при загрузке отношений из стороннего источника), не бегая по всем сущностям "Сотрудник", которые не сконцентрированы в едином месте

- расширяемость: при добавлении нового типа связи можем сделать это только в одном месте, не дописывая эту доп. логику во всех классах-реализациях

Ключевые аспекты:

- "под капотом" класс `RelationManager` содержит два контейнера, основанных на хэш-таблице; связь "начальник-->подчиненные" (подчиненных может быть много) и "подчиненный-->начальник" (начальник только один)

- принято решение использовать контейнеры из boost по соображениям быстродействия: https://www.boost.org/outreach/program_page/unordered

- для хранения "начальник-->подчиненные" используется boost::unordered_multimap, так как у одного начальника может быть много подчиненных

- для хранения "подчиненный-->начальник" используется boost::unordered_map, так как у подчиненного всего один начальник

###### Расчет зарплат

Зачем понадобился отдельный класс `SalaryCalculator`? Первоначальный вид - реализация функции расчета в каждом из классов-реализаций абстрактного `Employee`. Но здесь есть проблема: для расчета зп бригадира и менеджера нужна информация по прямым/всем подчиненным. То есть экземпляр `Employee` должен иметь доступ к хранилищу объектов/менеджеру связей подчинения. Противоречие в плане единства ответственности. Конечно, можно было бы внедрить в этот чистый виртуальный метод расчета доп. параметр - коллекцию указателей на `Employee`, однако это накладывает доп. задачи по осмыслению, как тут избавляться от копирования, а также не совсем подходит для масштабироввания, так как вполне может появиться новый класс-наследник со своей логикой расчета, из-за которой придется снова модифицировать интерфейс `Employee`.

Решение - вынести логику расчета в отдельную сущность, передавая ей в конструкторе харнилище и иерархию подчинения по константным ссылкам (dependecy injection).

## Возможные улучшения

- добавить логирование, используя сторонний интерфейс логгера, который вклюить в архитектуру по принципу dependency injection

- расширить функционал добавления сотрудников из стороннего источника

- расширить функционал сериализацией данных во вне (файл/БД и т.д.)

- улучшить проект с точки зрения tooling-а (проработать CI/CD pipeline; добавить логику генерации отчета по покрытию тестами)

- можно модифицировать функцию `add_employee` так, чтобы была возможность добавлять не только одного сотрудника, а сразу несколько, при этом не ограничивая пользователя библиотеки количеством (fold expression)

- можно модифицировать функцию `remove_employee` чтобы была возможность удалять не только одного сотрудника, а сразу несколько, при этом не ограничивая пользователя библиотеки количеством (fold expression)

- использовать в `EmployeeManager` shared_lock для операций чтения и unique_lock - для записи, чтобы была возможность разделять смысл доступа к дному и тому же объекту по операциям чтения/записи

- использовать в `RelationManager` shared_lock для операций чтения и unique_lock - для записи, чтобы была возможность разделять смысл доступа к дному и тому же объекту по операциям чтения/записи

- сигнатуры функций `get_chief`, `get_direct_subordinates` и `get_all_subordinates` поменять так, чтобы не было лишнего копирования данных (создание вектора uuid_t); использовать инструмент view/range из 20-го стандарта (как враиант)

- исследовать момент хранения отношений между сотрудниками в виде boost::unordered_map и boost::unordered_multimap; быть моежт, более удобным и производительным будет хранение в виде графа из Boost.Graph, так как по условию задачи иерархия представляет собой дерево (дерево - частный случай графа)

- распараллелить функционал расчета заработной платы; по идее во время чтения данных я защищаюсь lock_guard-ом так, что вся процедура расчета зп атомарная, подразумевающая, что в момент вызова (пока считаеся зп) список сотрудников не может быть модифицирован; в такой формулировке можно спокойно раскидывать задачи по потокам, так как я знаю, что храниоище на данном отрезке времени неизменно;

- провести фукциональное нагрузочное тестирование по принципу черного ящика с целью оценки производительности; скорее всего, оно покажет, что в условиях частого обращения к библиотеке за расчетом зп потребуется shared_lock (а сейчас используется lock_guard, т.е. эксклюзивная блокировка); ведь расчет зп - операция чтения, модификации тут нет

- продумать бизнес-логику в следующем моменте; сейчас во время калькуляции зп какой-то сторонний поток теоретически может изменить структуру подчинения, так как realtion контейнер не блокируется полностью на момент всей операции расчета; так ли это критично?

- продумать автоматизированное тестирование с генерацией абсолютно разных дат трудойстройства сотрудников и их подчиненных с учетом подсчета зп (фаззинг-тестирование)